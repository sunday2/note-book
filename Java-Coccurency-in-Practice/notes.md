* 不良并发(poor concurrency)
* 临界区(critical section)
* 内存可见性(memery visibility)
* 线程封闭(thread confinement)
* 定理

```
无状态对象一定是线程安全的。
```
```
无状态，说明即使该对象被多个线程共享，也没有状态可共享。
```

* 正确编程方法

```
首先使代码正确运行，然后再提高代码的速度。
```
```
即先实现功能，再优化。
```

* 线程安全类怎么实现的

```
在线程安全类中封装了必要的同步机制，因为客户端无须进一步采取同步措施。
```
```
面试经常问xxx类是线程安全的吗?比如经常用的HashMap是线程安全的吗？你会回答说不是，那么其对应的线程安全类是谁呢？其对应的线程安全类是HashTable，CoccurentHashMap。而HashTable如果你看过其源码就会发现，其实现线程安全的机制是在方法级别上加了synchronized关键字，也就是加了this互斥锁。当然，实际中我们会使用更好的CoccurrentHashMap来作为HashMap的并发类，其性能更好。
```

* 竞争条件(结果依赖于多个线程的执行顺序)类型

```
最常见的就是“先检查后执行”，即Check-Then-Act(a,b约时间去星巴克见面的例子)。
```
```
还有一个常见的Check-Then-Act例子就是延迟初始化，比如单例模式我们经常会说有懒汉式和饿汉式。首先提倡的是延迟加载的，因为很多时候初始化对象是个高开销的操作。其次，我们实现懒汉式经常举的例子是DCL，也就是double check lock的模式，其实这并不是最优的example，所以我一般都使用静态内部类来实现懒汉式。

```

* 复合操作

```
很多时候代码会给我们一个假象，比如a+=1这行代码，其实一开始我们以为它就是原子操作，但是其实在操作系统层次，其包括了三条指令，读取-修改-写入，所以在操作系统层次上它就是符合操作。意味着当t0，t1线程共享了该数据，它可以在任何一个指令上被其它线程中断，所以平时写代码一定要有意识的告诉自己这是一个复合操作。
```

* 如何将复合操作原子化

```
其实通过复合操作还是复合操作，所谓的原子化只是jvm层上的，我们并没有改变底层操作系统的逻辑。
```
```
(1)使用现有的线程安全对象
(2)使用锁机制
```

* 有哪些锁

```
(1)内置锁(intrinsic lock)或者监视器锁(monitor lock)或者叫同步代码块。使用java对象作为锁，配合syncronized使用。
```
```
其实编译器会在同步代码块前后加上lock和unlock。
为什么加锁能保证被加锁的区域线程安全呢？
其实本质上就是将加锁区域变成了只能串行执行，无论你有多少个线程对加锁区域进行并发操作。
```
```
(2)可重入锁，jdk已经有实现ReentrantLock。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用“。
```

```
之前面试官问java中的锁有哪些，什么是可重入锁?
因为可重入锁在实际应用中还是比较频繁的，我会按自己的理解解释一番，但是其实我自己觉得并没有扎到底。书中从锁的粒度上给了一个解释，我觉得真的给了一个思路，所以说每次读都会有不一样的收获。
synchronized是可重入的。

那为什么可重入锁在实际的应用会比较频繁呢？
因为可重入锁避免了自己锁死了自己的情况，也就是避免了死锁，否则会出现自己等待自己当前已经获取的锁的情况，这不是就是死锁了吗?死锁的情况无非就是
（1）a等待b已经获取到的锁，然后b等待a已经获取到的锁。
（2）a等待其自己已经持有的锁。

面试官可能还会问可重入锁是怎么实现的？
每个可重入锁会将其被持有的次数和持有的线程记录起来，也就是可重入锁每次还是都只能被一个线程持有，但是可以被已经持有的线程多次持有。所以，当计数值为0表示该锁未被任何线程持有，当计数值非0，意味着该锁被有且一个线程持有，而持有该锁的线程每退出一次锁的区域，计数值就减1。
```

* 何时使用同步

```
如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。
```

```
很多人以为只有对共享变量进行写操作的时候才需要使用同步，其实并不是。
```

```
首先，对共享变量的操作无非就是写和读操作。为什么读操作也不要同步呢？因为还有这样一种情况，t0线程对a进行写操作时，t1线程再对a进行读操作，那么如果不对读操作进行同步，t1线程就有可能读到一个脏数据。所以同步机制并不一定是在写操作才需要，读操作同样需要。
因为我们的认知中t0线程开始写操作就是代表已经写了，但是写操作是复合操作，包括了读-修改-写三个原子操作，在读的这个指令时，t1也对a进行了读操作，但是读到的是脏数据。

```

* 内置锁的设计目的

```
每个对象都有一个内置锁，只是为了免去显示地创建锁对象。
```

* 定理

```
每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁
```

```
所以，无论代码如何变化都好，本质上都有一个锁在那里。即使你的synchronized关键字是加在方法上的，当是对象方法时，本质上是对方法加了一个当前的对象锁；当时静态方法时，本质上是加了一个当前class对象锁。因此，在使用synchronized关键词的时候，我们都应该有意识的去想到底加的是哪一个锁。
```

* 避免混合使用同步机制

```
原子类的操作是线程安全的，但是原子类内部的同步机制使用的是无锁结构，当我们在synchronized块中可以避免使用原子类，因为使用两种不同的同步机制不仅可能会带来混乱，而且对性能和安全性上也不会带来任何好处。
```

* 在程序简单性和并发性取得平衡

```
意味着锁的粒度需要合理
```

* 定理

```
当执行时间较长的计算或者可能无法快速完成的操作时(例如网络io),一定不要持有锁。
```

* 无同步策略情况下并发可能出现的问题

```
1.没有同步情况下，编译器，处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整.
2.失效值问题.get和set方法得加锁，否则a线程调用set方法，b线程调用get方法，get会读到一个失效值，所以都得加上锁。
但是这种读到的set值也是某个线程之前set进去的，所以称为最低安全性(out-of-thin-airsafety)
3.非原子的64位操作，jvm会将64位的读操作或者写操作分解为两个32位的操作。所以对于共享和可变的long和double类型必须加锁或者使用volatile变量。
```

* 定理

```
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作和写操作的线程都必须在同一个锁上同步.
```

```
其实个人认为互斥和可见性是一种因果关系。并发编程中的问题是原子性，可见性，有序性
加锁保证了临界区的原子性，同时保证了可见性，有序性。
```

* volatile 变量

```
可见性的本质原因在于cpu缓存和jvm指令重排

那么使用volatile的变量jvm禁止缓存和指令重排(结合jvm的happened-before原则)
```

```
平时可以理解为被volatile修饰的变量相当于get和set加了锁（虽然实际上并没有加锁，但是和加锁的效果是一样的，所以性能更好）。但是，并不建议过度依赖volatile变量提供的可见性，因为其比加锁的代码更脆弱和难以理解。
```

```
volatile的典型用法：
检查某个状态标记以判断是否退出循环。
```

```java
volatile boolean asleep;
...
    while(!asleep)
        countSomeSheep();
```

* 使用volatile的实机

```
(1)对变量的写入操作不依赖变量的当前值,或者你能确保只有当个线程更新变量的值
(2)该变量不会与其他状态变量一起纳入不变性条件中。
(3)在访问变量时不需要加锁。
```

```
所以，实际上使用volatile的机会相对来说还是比较少的。
第一点，当有类似a+=1这种并发操作时，并且需要a+=1是原子操作时，并不适合将a使用volatile来声明。因为volatile的效果只是类似a的set和get方法进行了加锁来保证可见性。
第二点，其实不变性条件意思是该变量不需要和其他变量一起作为一个原子操作。
第三点，之前说过应该避免多个同步机制进行混合使用，会有性能或者安全问题。
```

* 发布(publish)

```
发布一个对象指的是使对象能够在当前作用域之外的代码中使用。
```
* 逸出(escaped)
```
当某个不应该发布的对象被发布时，这种情况就被称为逸出(escaped).
```
```java
public static Set<Scret> knownSecrets;

public void initialize(){
    knownSecrets = new HashSet<Secret>();
}
```

```
首先，对象的内存空间都是在堆空间开辟，但是可以可以通过对象的引用来控制它的作用域。上面的例子中，我们在方法作用域里new了一个对象，并把它赋予了一个静态引用，该引用是public，由当前作用域(方法作用域)提升到了全局作用域，由小到大，所以发布了。
```

```
所以判断是否发布，就判断是否从当前作用域提升到了一个更大的一个作用域，而且得注意发布的传递性。
```

```
判断是否逸出，则第一步判断是否发布了，第二部，判断该发布是否是应该的.
```

* 为什么要注意发布和逸出

```
当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。注意非静态内部类对外部类的隐含引用。
```

* 注意

```
当发布某个对象时，可能会间接地发布其他对象。因为当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。
```

* 定理

```
不要在构造过程中使this引用逸出
```

```
原因就是当且仅当对象的构造函数返回时,对象才处于可预测的和一致的状态。此时，如果对象的this引用在构造函数中逸出，此时若其它线程调用了该对象(因为逸出了，所以必须假设某个类或线程可能会误用该对象)，就会出现问题，因为此时该对象尚未完全构造完成。
```

```
具体来说，只有当构造函数返回时，this才应该从线程中逸出.构造函数可以将this引用保存到某个地方，只要其它线程不会在构造函数完成之前使用它，
```

```
所以，this可以在构造函数逸出，但是得保证其它线程不会在构造函数完成之前使用它。
```

* 线程封闭

```
需要使用同步的情况：多个线程访问共享的可变的数据。
```

```
所以，避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步，即使被封闭的对象并不是线程安全的。这种技术就是线程封闭，实现线程安全最简单的方式之一。常见应用是JDBC，虽然connectiond对象并不是线程安全的，但是但是connection pool的实现是线程安全的，被分配给其它线程的connection对象不会再分配给其它线程，所以connection是线程封闭的，它不会同时被多个线程持有。
```

* 线程封闭技术的种类

```
ad-hoc线程封闭:  
维护线程封闭性的职责完全由程序实现来承担。这种是非常脆弱的，不推荐使用
```

```
栈封闭:  
    局部变量的固有属性之一就是封闭在执行过程中。而在jvm的内存模型中，我们都知道栈空间是线程私有的空间，所以其他线程无法访问这个栈。它比ad-hoc线程封闭技术更易于维护和健壮。有一点有注意的是，在维护对象引用的栈封闭性时，程序员需要多做一些工作来防止被引用的对象逸出。
```

```
threadlocal类：
    这是最规范的线程封闭技术，它保证了线程中的某个值与保存值的对象关联起来。它本质是为每个使用该变量的线程都保存了副本，并提供了get和set方法，所以get总是返回由当前线程在调用set时设置的最新值。
    threadlocal对象通常用于防止对可变的单实例变量或全局变量进行共享。
    常见应用:
    1.维护一个全局的数据库连接，程序启动时初始化这个连接对象，由于这个连接并不是线程安全的，所以将连接对象保存在threadlocal中，这样每个线程获取连接时都会有该连接的副本，当线程结束时，该连接也会跟着被回收。但是这样会有个问题，如果有n个线程同时获取该连接，那么就会有n个connection的副本，如果一个连接占m内存大小，那么就占了虚拟机n*m的空间大小。可以理解为TreadLocal进行了全局对象的拷贝操作。
```

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<connection>(){
    public Connection initialValue(){
        return DriverManager.getConnection(DB_URL);
    }
}

public static Connection getConnection(){
    return connectionHolder.get();
}
```

```
在实现应用程序框架是大量使用了ThreadLocal.
```

* 对象不变性

```
定理:不可变对象一定是线程安全的，使用关键词final修饰。
```

* 小总结

```
什么时候会出现线程安全的问题:在线程之间共享了可变的对象。

我们提取到了两个关键词，可变，共享

所以从两个关键词入手，怎样防止非线程安全?
1.不进行共享，即线程封闭技术，典型的就是栈封闭(局部变量)，ThreadLocal。
2.让对象不可变.典型就是使用finla修饰对象。
3.当可变的变量仍然需要进行共享，那么我们常见的就是通过锁的机制
```

```
满足以下条件对象才是不可变的:
1.对象创建以后状态不可修改
2.对象的所有域都是final类型
3.对象是正确创建的(在对象的创建期间，this引用没有逸出)
```

* 设计线程安全的类

```
三个基本要素:
1.找出构成对象状态的所有变量
2.找出约束状态变量的不变性条件
3.建立对象状态的并发访问策略
```

```
1.对象的状态可能是基本类型字段，也可能是对象类型。如果是对象类型，那么对象的状态包括被引用对象的域。
2.找出在多线程访问对象的情况下，对象状态的不变性条件。确保它的不变性条件不会在并发访问的情况下被破坏。
3.同步策略，定义了如何在不违背对象不变性条件或后验条件的情况下对其状态的访问操作进行协同。
```

```java
@ThreadSafe
public final class Counter{
    private long value = 0;
    public synchronized long getValue(){
        return value;
    }
    public synchronized long increment(){
        if(value == Long.MAX_VALUE)
            throw new IllgegalStateException("counter overflow");
        return ++value;

   }

}
```

```
1.上面的例子中，构成对象的状态的所有变量只有一个，就是基本变量value
2.状态空间:即所有可能取值。上面的例子中，不变性条件包括
（1）value的状态空间(所有可能取值)为Long.MIN_VALUE到Long.MAX_VALUE;
（2）value不能是负值
（3）后验条件:判断状态迁移是否有效的。上面的例子中，如果value当前值为17，那么下一个值只能是18.
3.基于第二点的分析制定同步策略，由于第二点的第1，2小点并不会因为多线程的并发访问而破坏该不变性条件，所以不需要制定同步策略。但是第3小点的不变性(后验条件)在并发访问情况下会被破坏，所以我们需要为此制定同步策略，可以看到我们在getValue和increment方法上都加上了对象互斥锁。
increment方法加上锁是因为第3小点value的值每次只能+1这个约束条件。getValue方法加锁是因为increment并不是原子操作。

一个基本准则是:
如果一个不变性条件中包含多个变量,那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。

所以按这个准则，例子两个对value加锁是正确的。
```

* 定理

```
如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。
```

* 设计线程安全的类的补充	

```Ji
设计线程安全的类三步骤的第二步:
要考虑的状态有三类:
1.不变性条件：对象的状态是否是有效的
2.后验条件:状态转换是否有效.比如++i,进行同步操作的话，意味着i的状态变化每次都是+1，只能从1，2，3这样的一个状态变化
3.先验条件:有些操作要等到先验条件为真才执行,而先验条件可能会由于其他线程的操作而变成真。比如:不能从空队列中移除一个元素，在删除元素前，队列必须处于"非空的"状态。
```

```
设计线程安全的类三步骤中的第一步:
如果以某个对象为根结点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。
为什么是子集?
因为从对象可以达到的所有域中，有一部分不属于对象状态的一部分。
比如:
HashMap对象的逻辑状态包括所有的Map.Entry对象以及内部对象，即使这些对象都是一些独立的对象。
```

```
设计线程安全的类的三步骤中的第三步:
将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。
```

```java
@ThreadSafe
public class PersonSet{
    @GuardedBy
    private final Set<Person> mySet = new HashSet<Person>();
    
    public synchronized void addPerson(Person p){
        mySet.add(p);
    }
    
    public synchronized boolean containsPerson(Person p){
        return mySet.contains(p);
    }
    
    
}
```

```
//通过
封闭+加锁等机制=使一个类成为线程安全的
1.PersonSet的状态是由HashSet来管理的，而HashSet并非线程安全的(这里并未考虑Person对象包括的状态)
2.通过使用private访问控制符来修饰Set达到将Set封闭在类的一个实例中。 封闭
3.唯一能访问Set的代码路径是addPerson和containsPerson，它们均加上了锁，因此PersonSet的状态完由它的内置锁来保护。

所以说PesonSet是一个线程安全的类，即使构成其状态的Set并不是线程安全的。所谓类是否线程安全，指的是它的构成类的状态是否是线程安全的。
```

```
封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。
```



