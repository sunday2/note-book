* 不良并发(poor concurrency)
* 临界区(critical section)
* 内存可见性(memery visibility)
* 定理

```
无状态对象一定是线程安全的。
```
```
无状态，说明即使该对象被多个线程共享，也没有状态可共享。
```

* 正确编程方法

```
首先使代码正确运行，然后再提高代码的速度。
```
```
即先实现功能，再优化。
```

* 线程安全类怎么实现的

```
在线程安全类中封装了必要的同步机制，因为客户端无须进一步采取同步措施。
```
```
面试经常问xxx类是线程安全的吗?比如经常用的HashMap是线程安全的吗？你会回答说不是，那么其对应的线程安全类是谁呢？其对应的线程安全类是HashTable，CoccurentHashMap。而HashTable如果你看过其源码就会发现，其实现线程安全的机制是在方法级别上加了synchronized关键字，也就是加了this互斥锁。当然，实际中我们会使用更好的CoccurrentHashMap来作为HashMap的并发类，其性能更好。
```

* 竞争条件(结果依赖于多个线程的执行顺序)类型

```
最常见的就是“先检查后执行”，即Check-Then-Act(a,b约时间去星巴克见面的例子)。
```
```
还有一个常见的Check-Then-Act例子就是延迟初始化，比如单例模式我们经常会说有懒汉式和饿汉式。首先提倡的是延迟加载的，因为很多时候初始化对象是个高开销的操作。其次，我们实现懒汉式经常举的例子是DCL，也就是double check lock的模式，其实这并不是最优的example，所以我一般都使用静态内部类来实现懒汉式。

```

* 复合操作

```
很多时候代码会给我们一个假象，比如a+=1这行代码，其实一开始我们以为它就是原子操作，但是其实在操作系统层次，其包括了三条指令，读取-修改-写入，所以在操作系统层次上它就是符合操作。意味着当t0，t1线程共享了该数据，它可以在任何一个指令上被其它线程中断，所以平时写代码一定要有意识的告诉自己这是一个复合操作。
```

* 如何将复合操作原子化

```
其实通过复合操作还是复合操作，所谓的原子化只是jvm层上的，我们并没有改变底层操作系统的逻辑。
```
```
(1)使用现有的线程安全对象
(2)使用锁机制
```

* 有哪些锁

```
(1)内置锁(intrinsic lock)或者监视器锁(monitor lock)或者叫同步代码块。使用java对象作为锁，配合syncronized使用。
```
```
其实编译器会在同步代码块前后加上lock和unlock。
为什么加锁能保证被加锁的区域线程安全呢？
其实本质上就是将加锁区域变成了只能串行执行，无论你有多少个线程对加锁区域进行并发操作。
```
```
(2)可重入锁，jdk已经有实现ReentrantLock。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用“。
```

```
之前面试官问java中的锁有哪些，什么是可重入锁?
因为可重入锁在实际应用中还是比较频繁的，我会按自己的理解解释一番，但是其实我自己觉得并没有扎到底。书中从锁的粒度上给了一个解释，我觉得真的给了一个思路，所以说每次读都会有不一样的收获。
synchronized是可重入的。

那为什么可重入锁在实际的应用会比较频繁呢？
因为可重入锁避免了自己锁死了自己的情况，也就是避免了死锁，否则会出现自己等待自己当前已经获取的锁的情况，这不是就是死锁了吗?死锁的情况无非就是
（1）a等待b已经获取到的锁，然后b等待a已经获取到的锁。
（2）a等待其自己已经持有的锁。

面试官可能还会问可重入锁是怎么实现的？
每个可重入锁会将其被持有的次数和持有的线程记录起来，也就是可重入锁每次还是都只能被一个线程持有，但是可以被已经持有的线程多次持有。所以，当计数值为0表示该锁未被任何线程持有，当计数值非0，意味着该锁被有且一个线程持有，而持有该锁的线程每退出一次锁的区域，计数值就减1。
```

* 何时使用同步

```
如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。
```

```
很多人以为只有对共享变量进行写操作的时候才需要使用同步，其实并不是。
```

```
首先，对共享变量的操作无非就是写和读操作。为什么读操作也不要同步呢？因为还有这样一种情况，t0线程对a进行写操作时，t1线程再对a进行读操作，那么如果不对读操作进行同步，t1线程就有可能读到一个脏数据。所以同步机制并不一定是在写操作才需要，读操作同样需要。
因为我们的认知中t0线程开始写操作就是代表已经写了，但是写操作是复合操作，包括了读-修改-写三个原子操作，在读的这个指令时，t1也对a进行了读操作，但是读到的是脏数据。

```

* 内置锁的设计目的

```
每个对象都有一个内置锁，只是为了免去显示地创建锁对象。
```

* 定理

```
每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁
```

```
所以，无论代码如何变化都好，本质上都有一个锁在那里。即使你的synchronized关键字是加在方法上的，当是对象方法时，本质上是对方法加了一个当前的对象锁；当时静态方法时，本质上是加了一个当前class对象锁。因此，在使用synchronized关键词的时候，我们都应该有意识的去想到底加的是哪一个锁。
```

* 避免混合使用同步机制

```
原子类的操作是线程安全的，但是原子类内部的同步机制使用的是无锁结构，当我们在synchronized块中可以避免使用原子类，因为使用两种不同的同步机制不仅可能会带来混乱，而且对性能和安全性上也不会带来任何好处。
```

* 在程序简单性和并发性取得平衡

```
意味着锁的粒度需要合理
```

* 定理

```
当执行时间较长的计算或者可能无法快速完成的操作时(例如网络io),一定不要持有锁。
```

* 无同步策略情况下并发可能出现的问题

```
1.没有同步情况下，编译器，处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整.
2.失效值问题.get和set方法得加锁，否则a线程调用set方法，b线程调用get方法，get会读到一个失效值，所以都得加上锁。
但是这种读到的set值也是某个线程之前set进去的，所以称为最低安全性(out-of-thin-airsafety)
3.非原子的64位操作，jvm会将64位的读操作或者写操作分解为两个32位的操作。所以对于共享和可变的long和double类型必须加锁或者使用volatile变量。
```

* 定理

```
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作和写操作的线程都必须在同一个锁上同步.
```

```
其实个人认为互斥和可见性是一种因果关系。并发编程中的问题是原子性，可见性，有序性
加锁保证了临界区的原子性，同时保证了可见性，有序性。
```

* volatile 变量

```
可见性的本质原因在于cpu缓存和jvm指令重排

那么使用volatile的变量jvm禁止缓存和指令重排(结合jvm的happened-before原则)
```

```
平时可以理解为被volatile修饰的变量相当于get和set加了锁（虽然实际上并没有加锁，但是和加锁的效果是一样的，所以性能更好）。但是，并不建议过度依赖volatile变量提供的可见性，因为其比加锁的代码更脆弱和难以理解。
```

```
volatile的典型用法：
检查某个状态标记以判断是否退出循环。
```

```java
volatile boolean asleep;
...
    while(!asleep)
        countSomeSheep();
```

* 使用volatile的实机

```
(1)对变量的写入操作不依赖变量的当前值,或者你能确保只有当个线程更新变量的值
(2)该变量不会与其他状态变量一起纳入不变性条件中。
(3)在访问变量时不需要加锁。
```

```
所以，实际上使用volatile的机会相对来说还是比较少的。
第一点，当有类似a+=1这种并发操作时，并且需要a+=1是原子操作时，并不适合将a使用volatile来声明。因为volatile的效果只是类似a的set和get方法进行了加锁来保证可见性。
第二点，其实不变性条件意思是该变量不需要和其他变量一起作为一个原子操作。
第三点，之前说过应该避免多个同步机制进行混合使用，会有性能或者安全问题。
```

* 发布(publish)

```
发布一个对象指的是使对象能够在当前作用域之外的代码中使用。
```
* 逸出(escaped)
```
当某个不应该发布的对象被发布时，这种情况就被称为逸出(escaped).
```
```java
public static Set<Scret> knownSecrets;

public void initialize(){
    knownSecrets = new HashSet<Secret>();
}
```

```
首先，对象的内存空间都是在堆空间开辟，但是可以可以通过对象的引用来控制它的作用域。上面的例子中，我们在方法作用域里new了一个对象，并把它赋予了一个静态引用，该引用是public，由当前作用域(方法作用域)提升到了全局作用域，由小到大，所以发布了。
```

```
所以判断是否发布，就判断是否从当前作用域提升到了一个更大的一个作用域，而且得注意发布的传递性。
```

```
判断是否逸出，则第一步判断是否发布了，第二部，判断该发布是否是应该的.
```

* 为什么要注意发布和逸出

```
当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。注意非静态内部类对外部类的隐含引用。
```

* 

