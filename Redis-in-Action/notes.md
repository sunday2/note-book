* 非关系型数据库(non-relational database)
* 主数据库(primary database)
* 辅助数据库(auxiliary database)
* 内存存储(in-memoriy)
* 主存储(primary storage)
* 二级存储(secondary storage)



* 数据说话

```
用户可以很方便的将Redis扩展成一个包含数百GB数据,每秒处理上百万次请求.
```
```
tips:
数百G,上百万次
```
* Redis定义

```
是一个远程内存数据库,存储键和5种不同类型的值的映射,可以将存储在内存的键值对(K-V模型)数据持久化到硬盘,可以使用复制特性来扩展读性能,可以使用客户端分片来扩展写性能.
```

```
tips:
1.Redis的读写比关系型数据库快有一个关键的硬件原因在于Redis是内存级别的，而关系型数据库是磁盘级别的
2.容器都涉及一个读和写,IO经常会形成一个性能瓶颈所在,IO瓶颈又可以细分读和写两种.Redis通过复制特性来提升读性能,通过客户端分片来提升写性能.
```

```
tips:
通过客户端分片来提升写性能?
分片是一种将数据划分为多个部分的方法,怎么划分可以基于键包含的ID，基于键的散列值,或者基于以上两种.通过对数据进行分片,可以将数据存储到多台机器里面，也可以从多台机器里面获取数据.

所以分片本质上是为解决写性能的一个解决方案，但是分片同样可以提升读性能，因为数据存储到了多台机器上,那么读的并发性也提升了.阿里云产品消息中间件datahub也有一个分片功能，类似的效果.

通过复制特性来提升读性能?
复制特性除了提升读性能还有一个作用,故障转移(高可用).
(1)执行复制的从服务器会连接上主服务器,接收整个数据库的处始副本;
(2)之后主服务器执行的写(修改)命令,都会被发送给所有连接着的从服务器去执行,从而实时的更新从服务器的数据集.也就是主从服务器数据是一致的,所以客户端可以向任意一个从服务器发送读请求,避免对主服务器进行集中式的访问.


注意,Redis的主从复制(数据同步)机制不同阶段不一样的,
(1)从刚开始连接上主时,主会将那一刻它的整个数据副本数据传输给从,传输的是数据内容本身,这里显然是耗时的;
(2)从连上主后,数据同步是通过主将后续的数据写指令(修改指令)发送给从实现的,传输的是指令而非数据内容. 
```

* Redis和memcached的比较

```
在缓存存储上，这两者经常会作为比较.
异:
1.存储的数据类型.memcached只能存储字符串,而Redis除了字符串还有其余4种.
2.持久化方式.Redis支持自动以两种方式将数据写入硬盘(持久化).分别是snashot(RDB)快照方式,一种是Append only file(AOF).

同:
1.都是内存存储(in-memory)
2.性能上相差无几.

总结:Redis比memcached拥有更广泛的应用场景,并且能解决更广泛的问题.
Redis和其它存储的更多比较见P4表1-1.
```

* Redis和关系型数据库比较

```
异:
1.底层存储不同.关系型数据库数据写入到硬盘,Redis写入到内存.
2.性能不同.内存级别比硬盘级别更快.
3.约束不同.一个是非关系型的,不会要求Redis存储的不同数据进行关联.
同:
1.都存储数据.
```

* 什么时候使用Redis

```
1.程序对性能要求是不是很高,高到关系型数据库解决不了了.
2.使用Redis的话费用是否足够
3.当Redis服务器被关闭时,服务器存储的数据将何去何从.
```



* Redis值的数据结构类型	

```
Redis是个K-V映射模型，那么V中能支持5种数据结构类型.分别是STRING(字符串),LIST（列表),SET(集合),HASH(散列),ZSET(有序集合)

更详细的见P6表1-2
```

```
tips:
这个也是面试时经常考察redis时经常被问到的一个问题,其实Redis是个很容易使用的一个K-V映射集合,那么经常说到的数据结构类型,其实指的是K-V中的V支持的数据结构.注意是数据结构类型而不是数据类型,因为STRING数据结构中其实支持字符串,整数,浮点数.
ZSET和SET,LIST和容易混淆:
ZSET:虽然是称为有序集合,但其实它的结构和HASH类似,都是键值对,而不是SET,这点得注意.和SET相同的是ZSET中的键各不相同.而且ZSET中的值必须为浮点数.
SET:无序,不重复
LIST:有序,可重复
```

* 字符串数据结构类型

```
相关命令:
GET:获取存储在给定键中的值
SET:设置存储在给定键中的值
DEL:删除存储在给定键中的值(这个命令可以用于所有类型)
```

```
tips:
(1)Redis中每种数据结构类型都有其特有的一些命令,也有些命令是所有数据结构类型通用的,比如DEL.
(2)虽然命令众多,但是从大的方向上也就是4种,增删改查.比如get其实就是查操作,DEL就是删操作,SET包括了增和改操作.所以使用命令的时候可以把它们进行归类下,有助于记忆.
(3)平时使用的时候注意留意下各个命令的执行返回值.
```

* 列表数据结构类型

```
相关命令:
RPUSH:将给定值推入列表的右端
LRANGE:获取列表在给定范围上的所有值
LINDEX:获取列表在给定位置上的单个元素
LPOP:从列表的左端弹出一个值,并返回被弹出的值
```

* 集合数据结构类型

```
相关命令:
SADD:将给定元素添加到集合
SMEMBERS:返回集合包含的所有元素
SISMEMBER:检查给定元素是否在于集合中
SREM:如果给定的元素存在于集合中,那么移除这个元素
```

* 散列数据结构类型

```
相关命令:
HSET:在散列里面关联起给定的键值对
HGET:获取指定散列键的值
HGETALL:获取散列包含的所有键值对
HDEL:如果给定键存在于散列中里面,那么移除这个键
```

* 有序集合数据结构

```
相关命令:
ZADD:将一个带有给定分值对成员添加到有序集合里面
ZRANGE:根据元素在有序排列中所处的位置,从有序集合里面获取多个元素
ZRANGEBYSCORE:获取有序集合在给定分值范围内的所有元素
ZREM:如果给定成员存在于有序集合，那么移除这个成员
```

```
tips:
注意ZSET和其它数据结构的区别,它和集合相似的地方在于ZSET中的键是不允许重复的,它和HASH类似的地方在于它也是K-V型数据结构.另外,ZSET中的V必须是数字.
```

* Redis中的K-V中的K(命名空间)的命名规范

```
(1)大多数使用冒号(:)分割名字的不同部分(少数人使用英文句号，斜线，管道符，保持统一)
(2)由于有时候可能redis会被多个项目或者模块共用，所以命名空间最前面最好加上project或者module标识
例如:
test:article:92617
上述表明该key是属于test module/project下的。
```

* 实际应用中如何选择合适的数据结构

```
(1)了解5种数据结构的特点
(2)了解业务需求

1+2=合适的数据结构

一开始可以参考别人类似的需求选择的是哪种数据结构。
比如涉及到不可重复那么会考虑set，涉及到排序，最近之类的考虑zset。
```

* 小结

```
其实redis中宏观层次上来说就是个K-V模型，而5种数据结构指的是K-V模型中V支持的数据结构。
对于数据结构(容器)最基本的操作无非就是CRUD，即增删改查。
```

* 使用redis构建web应用的几个典型例子

```
登陆和cookie缓存:
(1)注意内存会随着redis存储的数据量而使用的越多，得考虑定时清理旧数据
(2)注意并发情况下的竞争条件的影响。分析其影响，如果影响不大，那么可以暂且不处理。比如在清除旧数据的同时刚好业务上有用到旧数据。

网页缓存:
网页缓存的目的是减少前端的负载，因为不常变的网页进行缓存，那么该网页的请求所需的数据就不需要再去查询数据库，这样子就降低了数据库的负载。所以网页缓存的本质是降低数据库负载，提高网页的响应速度(不用重新渲染)。可以根据该网页的实际变动频率设置缓存的时间。
具体实现方式:
(1)可以通过中间件(nginx)实现.判断请求是否在缓存页面列表里。没在缓存列表里的走正常流程，在缓存列表中的判断是否已经缓存，缓存失效或者未缓存则查询库，已经缓存且未失效则从缓存取。
(2)考虑缓存时间
网页缓存缓存的是整个页面(包括html这些)，还是单单缓存的是那个页面所需的数据?
现在主流都是前后端分离，并且渲染已经是在前端渲染而不是后端渲染(比如jsp)。那么缓存页面可以通过中间件的配置来实现，比如nginx?这样nginx缓存的就是整个页面(已经渲染好的，渲染时间+查询库时间)，对于前后端分离的，那么redis应该缓存的是那个页面所需的数据(仅仅节省了查询库的时间)，这个可以考虑通过过滤器来实现。

数据行缓存:
网页缓存的缓存粒度是比较大的，一般这种页面跟静态页面差不多。那么可能更多时候是对数据行进行缓存。就是把关系数据库的一行格式化为json字符串，然后作为String类型放到Redis里面。

具体实现:
一开始我想到的是编写周期性任务将指定的行周期性进行缓存和更新。后面发现书中的设计更抽象了一层，更具弹性。值得借鉴。
(1)编写一个持续运行的守护进程函数(进程?通过一个一直运行的线程)，让这个函数将指定的数据行缓存到Redis中，并不定期地对这些缓存进行更行
(2)事先需要设计两个有序集合来记录应该在何时对缓存进行更新。提前写入值。
第一个集合为调度有序集合，成员为数据行的行ID，分值是一个时间戳，时间戳表示在何时将指定数据行缓存到Redis里面；
第二个有序集合为延时有序集合，成员为数据行的行ID，分值记录了指定数据行的缓存需要每隔多少秒更新一次。

相关程序查阅书籍P32。

数据行缓存的思考:
(1)一个行使用什么作为行ID？
主键么？
(2)为什么不直接只是存储行ID和对应delay时间?
既然需要存储行ID和其对应的更新频率，那么显然每一行数据的更新频率是不一样的。如果只保存这两个值的话，程序根本无法实现不同缓存行不同更新频率。如果通过周期性任务中的周期来定义更新频率，那就意味着所有缓存行的更新频率是一样的。所以这里需要使用两个有序集合(注意，有序)，整个守护进程函数(线程实现也是可以的吧)的宏观上的逻辑是每次循环会去获取最新的调度有序集合，然后取出这个集合的第一个元素，没错，每次都是获取最新，并且都是第一个元素。(这个就是设计的绝妙之处，这个集合是有序的，且是根据缓存行的下一次需要更新时间进行排序的，所以第一个元素的时间肯定是最早的，也就是最需要被更新的缓存行，具体阅读代码)。然后判断这个元素的时间和当前时间比较，如果没有元素或者这个第一元素比当前时间晚(意味着还没到更新时间)，那么再睡眠一阵子，然后重新取。如果更新时间早于当前时间，那么再取出其对应的delay时间，如果delay小于等于0，那么不缓存这个行，将它从缓存中移除(没错，通过delay时间来控制是否需要进行缓存)。如果delay时间大于0，那么更新缓存行，并且更新缓存行的下一次更新时间.(注意，下一次更新时间是由当前时间+delay时间计算出来的，而且那个容器是有序的，会自动触发重新排序，所以循环体中每次都得获取最行的zset).

网页分析:
由于服务器的内存有限，我们不可能对所有想缓存的数据进行缓存，缓存应该用在刀刃上。具体用到再参考



```



